= Go SDK tutorial
:page-topic-type: concept

[abstract]
The Go SDK tutorial introduces some advanced concepts by walking through a complete web application.

The full source code for the tutorial is available https://github.com/couchbaselabs/try-cb-golang/[on GitHub^].
The primary focus of the tutorial is to explain the function and theory behind the Couchbase Go client and how it connects to Couchbase server.
The tutorial highlights new features in Couchbase version 4.0 such as the N1QL query language.
It makes use of the `travel-sample` bucket that is provided with Couchbase Server.
The code that generates the web application is provided with the source code but is not discussed in this tutorial.

== Prerequisites and setup

To go through the tutorial, you'll need the following:

* Your favorite IDE or editor.
The https://atom.io[Atom^] text editor, with the https://github.com/joefitzgerald/go-plus[go-plus plugin^] installed, provides a great Go IDE experience.
This tutorial is IDE agnostic.
* Go 1.4 or higher.
This tutorial was written and tested using Go 1.5.
* The sample app source code from GitHub (this tutorial cover only the Go part of the app).
The data model and AngularJS front end are explained in detail in the http://developer.couchbase.com/documentation/server/4.0/travel-app/travel-app-data-model.html[travel-sample walkthrough^].
* A local `Couchbase Server 4.0` installation.
Make sure that the sample bucket named `travel-sample` is loaded and that there is at least one node with data, query, and index services in the cluster.
+
If you already have Couchbase Server installed but did not install the `travel-sample` bucket, open the Couchbase Web Console and select menu:Settings[Sample Buckets].
Select the `travel-sample` check box, and then click [.ui]*Create*.
A notification box in the upper-right corner disappears when the bucket is ready to use.

To run the tutorial app:

* As long as your `GOPATH` environment variable is set up correctly, you should be able to install from the terminal by using the following command:
+
[source,bash]
----
go get github.com/couchbaselabs/try-cb-golang
----

* If you don't want to connect to `localhost`, you need to change the configuration set up in the connection statement in the [.path]_try.go_ file (`cluster, _ := gocb.Connect("couchbase://127.0.0.1")`.
You can use either an IP address or a host name in the string.
* Open [.path]_try.go_ (located under [.path]_$GOPATH/src/github.com/couchbaselabs/try-cb-golang_)
* Alternatively, go straight to running the project:
+
[source,bash]
----
go run try.go
----

== Configuring and bootstrapping the SDK

Configuring and bootstrapping the SDK involves connecting to the `Cluster` and getting a reference to a `Bucket`.
You can find the code discussed in this section in the [.path]_try.go_ file on lines 4 and 18 and lines 340–341 in the [.api]`func main()` method.

The first step is to let the application connect to your cluster and obtain a reference to a `Bucket` object.
The bucket is your entry point for the whole storage API.
Both `Cluster` and `Bucket` should be reused across your application.
They are instantiated within the [.api]`main()` function so they can be used across the application.

Import the Couchbase Go client in the import code block:

[source,go]
----
"github.com/couchbase/gocb"
----

Declare a pointer to be used for the Couchbase bucket:

[source,go]
----
var bucket *gocb.Bucket
----

Various functions within the application use the `bucket` variable.
The cluster and bucket references are instantiated in `func main()`.

TIP: For best results always use a bucket by reference.
Declaring the bucket variable as a pointer to the Couchbase bucket allows the bucket connection to be used by reference.
This is extremely important for performance.
Applications that spin up, execute, and tear down connections for each operation within an application are inefficient, resource-intensive, cause garbage collection headaches, and are not performant.

The following code snippet connects to the cluster and opens the `travel-sample` bucket:

[source,go]
----
cluster, _ := gocb.Connect("couchbase://127.0.0.1")
bucket, _ = cluster.OpenBucket("travel-sample","")
----

From within `func main()` we connect to the cluster, and then open the database (bucket).
This allows us to use sample data from `travel-sample`.
For using secure credentials reference `OpenBucket` from within the API http://godoc.org/github.com/couchbase/gocb[docs^].

The application is now ready to use the Couchbase API.
To learn more about configuring the client and connecting to a bucket, see xref:managing-connections.adoc[Managing connections].

== Managing users by using the key-value API

The Go SDK provides key-value operations on buckets that the app uses to manage users.
You can find the code discussed in this section in the [.path]_try.go_ file in [.api]`func loginHandler()` method on lines 262–295.

Couchbase Server is both a document-oriented store and a key-value store.
It can be used purely as a key-value store, such as for caching, but it also offers advanced document oriented capabilities based on JSON documents such as indexing, views, and N1QL querying.
This is noticeable in the API, where the methods reflect key-value operations (such as `get` and `insert`) and work with a `value` interface pointer.
Go's built-in JSON support for marshaling and unmarshaling is a natural fit for working with JSON documents stored in Couchbase Server.

TIP: The Couchbase Go client always returns a pointer to an interface variable for retrieval operations, which greatly simplifies loading results into structs.

*Creating new users*

These are the steps for creating new users:

. Route the HTTP request and check if it's a `POST` (new user) or `GET` (existing user) request.
. Check if a user exists.
. Create a new user with a JSON web token.
. Save the new user.
. Return the JSON web token in a response

*Route the HTTP request*

Go's built in `net/http` package is extremely simple for routing requests.
In `func main()` we route the request to the predefined request handler `loginHandler`:

[source,go]
----
http.HandleFunc("/api/user/login",loginHandler)
----

Within the `func loginHandler()`, we can check the request type by looking at the request method.
The request method is interrogated from a pointer to the request itself `r.Method`.
A `"POST"` is a new user.

[source,go]
----
	switch r.Method {
		case "GET":
			// login request for existing user
			q.User = r.URL.Query().Get("user")
			q.Password = r.URL.Query().Get("password")
			if authenticated:=q.LoginUser(); authenticated==true{
				s.Success=q.Token
				bytes,_:=json.Marshal(s)
				w.Write(bytes)
			}else{
				bytes:=[]byte(`{"failure":"Bad Username or Password"}`)
				w.Write(bytes)
			}
		case "POST":
			// login request for a new user
			_ = json.NewDecoder(r.Body).Decode(&q)
			if exists := q.CheckUserExists(); exists == true {
				bytes:=[]byte(`{"failure":"User exists, please choose a different username"}`)
				w.Write(bytes)
			}
			if created := q.CreateUser(); created == true {
				s.Success=q.Token
				bytes,_:=json.Marshal(s)
				w.Write(bytes)
			}
		}
}
----

*Check if the user exists*

Now we use the key-value API to determine if the new user we are going to create already exists.
First we define a variable `curUser` from our `User struct`.

[source,go]
----
type User struct {
	Type string `json:"_type"`
	ID string `json:"_id"`
	Name string `json:"name"`
	Password string `json:"password"`
	Token string `json:"token"`
	Flights []UserFlight `json:"flights"`
}
----

Then from our `bucket.Get()` call we pass in a reference to that variable.
If the user we're trying to create exists, the `curUser` variable is populated.
The function returns `true` or `false` depending on if the user was found.

[source,go]
----
func (u *UserIntermediary) CheckUserExists() bool{
	var curUser User
	if _,err := bucket.Get(u.User,&curUser); err != nil{
		return false
	}
	return true
}
----

*Create a new user and return a JSON web token*

In this step we create a new instance of a `User` and assign the fields based on the information provided.
We also create a new JSON web token based on the credentials.
Because our `User` struct, shown above, is a native JSON document, storing this struct into Couchbase is simple.
We insert the document into Couchbase using the `Username` field as the key, and the `User` struct instance as the value.
After the User is stored, the application responds with the JSON token.

[source,go]
----
func (u *UserIntermediary) CreateUser() bool{
	token := jwt.New(jwt.SigningMethodHS256)
	token.Claims["user"] = u.User
	if encryptedToken, err := token.SignedString([]byte(hashToken)); err != nil{
		return false
	} else {
		u.Token=encryptedToken
	}

	var newUser User
	newUser.Type = "User"
	newUser.ID = "NOT_CURRENTLY_USED"
	newUser.Name = u.User
	newUser.Password = u.Password
	newUser.Token = u.Token
	if _, err := bucket.Insert(newUser.Name, newUser, 0); err != nil{
			return false
	}
	return true
}
----

To learn more about working with documents, see xref:documents.adoc[Working with Documents], xref:storing.adoc[Creating documents], xref:retrieving.adoc[Retrieving documents], and xref:updating.adoc[Updating documents].

== Finding airports by using N1QL queries

The Go SDK provides several methods for querying documents in Couchbase.
These methods operate on views, geospatial views, and N1QL queries.
You can find the code discussed in this section in the [.path]_try.go_ file in the [.api]`airportHandler()` method on lines 151–181.

The query types within Go are `SpatialQuery`, `ViewQuery`, and `N1qlQuery`.
For N1QL, the `N1qlQuery` type is expected.
This allows us to wrap a N1QL statement in `N1qlQuery`, provide query tuning through a `params` interface.
The N1qlQuery is then run by the `bucket.ExecuteN1qlQuery()` method.

TIP: N1QL is a superset of SQL, so if you're familiar with SQL, you will feel at ease.

Let's issue our first `SELECT` query to find a list of airports that match a specified search string.

The `func airportHandler()` first builds the query string based on the search string provided.
We want to search by different fields like FAA, ICAO and to convert to all capitals if we're searching by those particular fields.

[source,go]
----
	var queryPrep string

	switch search := r.URL.Query().Get("search"); len(search) {
	case 3:
		queryPrep = "SELECT airportname FROM `travel-sample` WHERE faa ='" + strings.ToUpper(search) + "'"
	case 4:
		if s:=strings.ToUpper(search); s==search {
			queryPrep = "SELECT airportname FROM `travel-sample` WHERE icao ='" + strings.ToUpper(search) + "'"
		}else{
			queryPrep = "SELECT airportname FROM `travel-sample` WHERE airportname like '" + search + "%'"
		}
	default:
		queryPrep = "SELECT airportname FROM `travel-sample` WHERE airportname like '" + search + "%'"
	}
----

TIP: N1QL uses the backtick (`) character for escape sequences.
Go also uses the backtick for escape sequences in `struct` definitions.

We'll want to select just the airport name from relevant documents in our `bucket`.
After the query string is built, we define it as a query statement and then run using `bucket.ExecuteN1qlQuery`.
Each N1QL query returns these values:

* an `interface{}` type
* an error, if one is returned

[source,go]
----
     myQuery := gocb.NewN1qlQuery(queryPrep)
     rows,err := bucket.ExecuteN1qlQuery(myQuery,nil)
----

We then loop through the results, and return the results in JSON format back in a response.

[source,go]
----
    var airports []Airport
	var row Airport
	for rows.Next(&row){
		airports=append(airports,row)
	}
	bytes,_:=json.Marshal(airports)
	w.Write(bytes)
----

To learn more about writing N1QL queries, see xref:querying.adoc[Working with N1QL queries].

== Finding routes by using complex queries

This application also demonstrates complex queries that use UNION, JOIN, and UNNEST clauses.
You can find the code discussed in this section in the [.path]_try.go_ file in the [.api]`flightPathHandler()` method on lines 184–248.

The following query uses a UNION clause to go from human-readable airport names for the departure and arrival airports to FAA codes that allow us to search on available flights by route.
Routes have departure and arrival airport fields defined by FAA codes:

[source,sql]
----
SELECT faa AS fromAirport FROM `travel-sample` WHERE airportname = "Los Angeles Intl"
UNION SELECT faa AS toAirport FROM `travel-sample` WHERE airportname = "San Francisco Intl"
----

This query constructs the result set of available flight paths that connect the two airports:

[source,sql]
----
SELECT a.name, s.flight, s.utc, r.sourceairport, r.destinationairport, r.equipment
FROM `travel-sample` AS r
UNNEST r.schedule AS s
JOIN `travel-sample` AS a ON KEYS r.airlineid
WHERE r.sourceairport = "LAX" AND r.destinationairport = "SFO" AND s.day = 6
ORDER BY a.name ASC
----

N1QL can do joins on a single bucket or several buckets.
It works as long as the foreign key described by an `ON KEYS` clause can be mapped to a document's key in the joined bucket.

A powerful feature of N1QL shown in the second statement is the UNNEST clause.
It extracts fields within an embedded JSON document within a result set and puts it at the same root level as the bucket.
Doing so, it makes it possible to do joins on each element in this embedded JSON as if they were entries in a left-hand side bucket.

The `funcFlightPathHandler()` method implements the above functionality including date verification, calculating flight duration, calculating pricing, and returns the response.

[source,go]
----
func flightPathHandler(w http.ResponseWriter, r *http.Request) {

      	var queryPrep, queryTo, queryFrom string
      	var fromLon, fromLat, toLon, toLat, dist float64
      	var price, flightTime, weekday int
      	var leave time.Time
      	var row AirportIntermediary
      	var airports []AirportIntermediary
      	var flight Flight
      	var flights []Flight

      	from := r.URL.Query().Get("from")
      	to := r.URL.Query().Get("to")

      	leave,_ = time.Parse(layout,r.URL.Query().Get("leave"))
      	weekday = int(leave.Weekday())+1

      	queryPrep = "SELECT faa as fromAirport,geo FROM `travel-sample` WHERE airportname = '" + from +
      	        "' UNION SELECT faa as toAirport,geo FROM `travel-sample` WHERE airportname = '" + to + "'"

      	myQuery := gocb.NewN1qlQuery(queryPrep)
      	rows,err := bucket.ExecuteN1qlQuery(myQuery,nil)
      	if err!=nil{
      		fmt.Println("ERROR EXECUTING N1QL QUERY:",err)
      	}

      	for rows.Next(&row) {
      		airports = append(airports,row)
      		if row.ToAirport!="" {
      			toLat=row.Geo.Lat
      			toLon=row.Geo.Lon
      			queryTo=row.ToAirport
      		}
      		if row.FromAirport!="" {
      			fromLat=row.Geo.Lat
      			fromLon=row.Geo.Lon
      			queryFrom=row.FromAirport
      		}
      		row = AirportIntermediary{}
      	}
      	dist = Haversine(fromLon,fromLat,toLon,toLat)
      	flightTime = int(dist/averageKilometersHour)
      	price = int(dist * distanceCostMultiplier)

      	_ = rows.Close()

      	queryPrep="SELECT r.id, a.name, s.flight, s.utc, r.sourceairport, r.destinationairport, r.equipment " +
                  "FROM `travel-sample` r UNNEST r.schedule s JOIN `travel-sample` a ON KEYS r.airlineid WHERE r.sourceairport='" +
      						queryFrom + "' AND r.destinationairport='" + queryTo + "' AND s.day=" + strconv.Itoa(weekday) + " ORDER BY a.name"

      	myQuery = gocb.NewN1qlQuery(queryPrep)
      	rows,err = bucket.ExecuteN1qlQuery(myQuery,nil)
      	if err!=nil{
      		fmt.Println("ERROR EXECUTING N1QL QUERY:",err)
      	}

      	for i:=0; rows.Next(&flight);i++ {
      		flight.Flighttime=flightTime
      		flight.Price=price
      		flights=append(flights,flight)
      	}
      	_ = rows.Close()
      	bytes,_:=json.Marshal(flights)
      	w.Write(bytes)
      }
----
