= Managing Connections Using the Go SDK with Couchbase Server
:navtitle: Managing Connections
:page-topic-type: concept
:page-aliases: howtos:managing-connections,howtos:multi-network,connecting,connection-advanced

[abstract]
This section describes how to connect the Go SDK to a Couchbase cluster and bucket.
It contains best practices as well as information on the connection string,  SSL and other advanced connection options.

== Creating a Cluster Object

The [.api]`Cluster` object serves as an organizational unit for any [.api]`Bucket` objects created.
As on the server each bucket is a member of a cluster, likewise in the SDK each [.api]`Bucket` object is a child of a [.api]`Cluster`.
To create a cluster, construct it using a _connection string_, specifying the scheme and host(s) to connect to [.api]`gocb.Connect`:

[source,go]
----
cluster, err := gocb.Connect("couchbase://localhost")
----

Any Cluster node host addresses passed in to establish (bootstrap) the connection should be for data (KV) nodes.
You can also specify multiple hosts in the connection string by separating each host with a comma:

[source,go]
----
cluster, err := gocb.Connect("couchbase://host1,host2,host3,hostN")
----

Specifying multiple hosts may add xref:failure-considerations.adoc[additional redundancy] when bootstrapping.

[NOTE]
====
From Couchbase Go SDK 1.4.0, [.api]`AlternateAddress` is implemented, for connecting to nodes in a NATed environment, such as Docker containers using portmapping. It is on by default, if the server provides a topology that includes a multi-network configuration. Whichever network is selected at bootstrap will be logged.

Note that any SSL/TLS certificates must be set up at the point where the connections are being made.  The Couchbase SDKs will honor any valid SSL/TLS certificates.
====

== Authenticating

From Couchbase Server 5.0, you will need to authenticate the user, rather than against the bucket, as part of xref:6.0@server:learn:security/authorization-overview.adoc[Role-Based Access Control].
You will need to use `PasswordAuthenticator`:

[source,go]
----
cluster.Authenticate(gocb.PasswordAuthenticator{
     Username: username,
     Password: password,
 })
----

== Opening a Bucket

Once the [.api]`Cluster` object has been created, you may open one or more [.api]`Bucket` objects using [.api]`Cluster.OpenBucket`.
The first argument is the bucket name to use, and the second is the bucket password - which should be provided if the bucket is password protected, or supplied as `nil` otherwise.

[source,go]
----
bucket1, err := cluster.OpenBucket("messages", nil)
protectedBucket, err := cluster.OpenBucket("protected", "s3cr3t")
----

Note that the bucket password is _not_ the administrative password used to access the Couchbase Web UI.

Once the bucket has been created, it may be used throughout your application.
Buckets are thread-safe and need not be locked or otherwise protected to be used from multiple threads.

You should only need to open one [.api]`Bucket` object for each Couchbase Bucket in your application, and you should attempt to keep the [.api]`Bucket` object available and open for as long as you plan to access Couchbase within your application.

include::6.0@sdk:pages:partial$max-connections.adoc[tag=limits]

== Closing a Bucket

When your application is done talking to Couchbase, you can issue the [.api]`Bucket.Close()` call on the bucket, which will disconnect your application from the given bucket.

[#ssl]
== Secure Connections with TLS

Couchbase Server Enterprise Edition supports full encryption of client-side traffic using Transport Layer Security (TLS).
That includes key-value type operations, queries, and configuration communication.
Make sure you have the Enterprise Edition of Couchbase Server before proceeding with configuring encryption on the client side.

To configure encryption for the Go SDK:

. Get the CA certificate from the cluster and save it in a text file.
. Enable encryption on the client side and point it to the file containing the certificate.

It is important to make sure you are transferring the certificate in an encrypted manner from the server to the client side, so either copy it through SSH or through a similar secure mechanism.

If you are running on `localhost` and just want to enable TLS for a development machine, just copying and pasting it suffices
-- _so long as you use `127.0.0.1` rather than `localhost` in the connection string_.
This is because the certificate will not match the name _localhost_.

Navigate in the admin UI to menu:Settings[Cluster] and copy the input box of the TLS certificate into a file on your machine.
It looks similar to this:

----
-----BEGIN CERTIFICATE-----
MIICmDCCAYKgAwIBAgIIE4FSjsc3nyIwCwYJKoZIhvcNAQEFMAwxCjAIBgNVBAMT
ASowHhcNMTMwMTAxMDAwMDAwWhcNNDkxMjMxMjM1OTU5WjAMMQowCAYDVQQDEwEq
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzz2I3Gi1XcOCNRVYwY5R
................................................................
mgDnQI8nw2arBRoseLpF6WNw22CawxHVOlMceQaGOW9gqKNBN948EvJJ55Dhl7qG
BQp8sR0J6BsSc86jItQtK9eQWRg62+/XsgVCmDjrB5owHPz+vZPYhsMWixVhLjPJ
mkzeUUj/kschgQ0BWT+N+pyKAFFafjwFYtD0e5NwFUUBfsOyQtYV9xu3fw+T2N8S
itfGtmmlEfaplVGzGPaG0Eyr53g5g2BgQbi5l5Tt2awqhd22WOVbCalABd9t2IoI
F4+FjEqAEIr1mQepDaNM0gEfVcgd2SzGhC3yhYFBAH//8W4DUot5ciEhoBs=
-----END CERTIFICATE-----
----

The next step is to enable encryption and pass it the path to the certificate file.

[source,golang]
----
myCluster, _ := gocb.Connect("couchbases://10.1.1.1?cacertpath=/path/to/ca.pem")

cluster.Authenticate(gocb.PasswordAuthenticator
     {      Username: username,      Password: password, }
     )

myBucket, _ := myCluster.OpenBucket("default", "")
----

If you want to verify that it's actually working, you can use a tool like `tcpdump`.
For example, an unencrypted upsert request looks like this (using `sudo tcpdump -i lo0 -A -s 0 port 11210`):

----
E..e..@.@.............+......q{...#..Y.....
.E...Ey........9........................id{"key":"value"}
----

After enabling encryption, you cannot inspect the traffic in cleartext (same upsert request, but watched on port 11207 which is the default encrypted port):

----
E.....@.@.............+....Z.'yZ..#........
..... ...xuG.O=.#.........?.Q)8..D...S.W.4.-#....@7...^.Gk.4.t..C+......6..)}......N..m..o.3...d.,.	...W.....U..
.%v.....4....m*...A.2I.1.&.*,6+..#..#.5
----


include::6.0@sdk:shared:partial$dnssrv-pars.adoc[tag=dnssrv]

To use DNS SRV in the Go SDK, simply pass the single bootstrap node (in this case `couchbase://example.com`).
DNS SRV lookup will not be performed if there is more than a single node in the bootstrap list.
